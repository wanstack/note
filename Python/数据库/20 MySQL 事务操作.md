[toc]

# 基础知识

事务是指对一组`SQL`语句进行一个原子化的操作，即如果这一组`SQL`语句中有一条发生错误，那么其他的同组`SQL`就都不会被执行。

你可以把它当作一个测试，当你执行完一组`SQL`语句后，可以查看一下结果是否正确，如果正确后可以选择提交，如果不正确则可以进行回滚，恢复到原本的状态。

在`MySQL`中，所有的操作默认都是自动进行提交，当开启事务后则变为手动提交。



# 基本使用



## 单独开启

单独开启是指对某一组的`SQL`语句开启事务。

```sql
CREATE TABLE user(
        id INT UNSIGNED AUTO_INCREMENT PRIMARY KEY,
        name CHAR(12) NOT NULL,
        balance INT UNSIGNED 
); -- 创建用户表

INSERT INTO user(name,balance) VALUES
        ("Yunya",1000),
        ("Ken",500); -- 插入数据


start transaction; -- 开启事务，增删改操作均要手动提交

        UPDATE user SET balance = 500 WHERE name = "Yunya"; -- Yunya对Ken转账500
        UPDATE user SET balance = 1000 WHERE name = "Ken";
        SELECT * FROM user; -- 验证是否出错

        COMMIT; -- 提交事务：手动提交上面两条UPDATE
        -- ROLLBACK; -- 事务回滚：转账金额不对时使用回滚

BEGIN -- 关闭事务，增删改操作均自动提交
```



## 全局开启

如果所有`SQL`都使用事务操作，我们可以通过 `SET AUTOCOMMIT=0` 关闭自动提交来开启事务机制，这样所有语句都是事务类型。

```sql
-- 关闭自动提交
SET AUTOCOMMIT = 0;

INSERT INTO user(name,balance) VALUES
	('Jack',8000);
	
COMMIT;

-- 开启自动提交
SET AUTOCOMMIT = 1;
```



# 事务隔离



## 并发问题

当高并发访问会遇到多个事务的隔离问题，可能会出现以下：

> 1. 脏读：事务A读取了事务B更新的数据，然后B回滚操作，那么A读取到的数据是脏数据
> 2. 不可重复读：事务A多次读取同一数据，事务B在事务A多次读取的过程中，对数据作了更新并提交，导致事务A多次读取同一数据时，结果不一致。
> 3. 幻读：系统管理员A将数据库中所有学生的成绩从具体分数改为ABCDE等级，但是系统管理员B就在这个时候插入了一条具体分数的记录，当系统管理员A改结束后发现还有一条记录没有改过来，就好像发生了幻觉一样，这就叫幻读。

不可重复读的和幻读很容易混淆，不可重复读侧重于修改，幻读侧重于新增或删除。解决不可重复读的问题只需锁住满足条件的行，解决幻读需要锁表



## 隔离级别

系统默认隔离级别为3级，可能出现幻读的情况。

| 隔离级别         | 中文释义   | 脏读 | 不可重复读 | 幻读 | 说明                                                         |
| ---------------- | ---------- | ---- | ---------- | ---- | ------------------------------------------------------------ |
| read uncommitted | 读未提交   | 是   | 是         | 是   | 最低的事务隔离级别，一个事务还没提交时，它做的变更就能被别的事务看到 |
| read committed   | 不可重复读 | 否   | 是         | 是   | 保证一个事物提交后才能被另外一个事务读取。另外一个事务不能读取该事物未提交的数据 |
| repeatable read  | 可重复读   | 否   | 否         | 是   | 多次读取同一范围的数据会返回第一次查询的快照，即使其他事务对该数据做了更新修改。事务在执行期间看到的数据前后必须是一致的 |
| serializable     | 串行化     | 否   | 否         | 否   | 事务 100% 隔离，可避免脏读、不可重复读、幻读的发生。花费最高代价但最可靠的事务隔离级别 |

一般来说系统默认的3级就足以应付大部分应用场景，但是设计金融类数据时一定要慎重。



## 查询设置

查询隔离级别

```text
select @@tx_isolation;
```

设置隔离级别

```text
set session transaction isolation level read uncommitted; -- set session只对当前会话有效，set global则对全局有效
```