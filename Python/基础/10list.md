[toc]

### 10. list

Python中的列表（list）是最常用的数据类型之一。

Python中的列表可以存储任意类型的数据，这与其他语言中的数组（array）不同。

被存入列表中的内容可称之为元素（element）或者数据项（data item）亦或是值（value）。

虽然Python列表支持存储任意类型的数据项，但不建议这么做，事实上这么做的概率也很低

#### 特性

列表特性如下：

1. 列表属于线性容器序列
2. 列表属于可变类型，即对象本身的属性会根据外部变化而变化，例如长度
3. 列表底层由顺序存储组成，而顺序存储是线性结构的一种

#### 声明

以下是使用类实例化的形式进行对象声明：

```python
lst = list((1, 2, 3, 4, 5))
print("value : %r\ntype : %r" % (lst, type(lst)))

# value : [1, 2, 3, 4, 5]
# type : <class 'list'>

```

也可以选择使用更方便的字面量形式进行对象声明，利用[]对数据项进行包裹，并且使用逗号将数据项之间进行分割：

```python
lst = [1, 2, 3, 4, 5]
print("value : %r\ntype : %r" % (lst, type(lst)))

# value : [1, 2, 3, 4, 5]
# type : <class 'list'>

```

#### 多维列表

当一个列表中嵌套另一个列表，该列表就可以称为多维列表。

如下，定义一个2维列表：

```python
lst = [1, 2, ["三","四"]]
print("value : %r\ntype : %r" % (lst, type(lst)))

# value : [1, 2, ['三', '四']]
# type : <class 'list'>

```

#### 续航操作

在Python中，列表中的数据项如果过多，可能会导致整个列表太长，太长的列表是不符合PEP8规范的。

- 每行最大的字符数不可超过79，文档字符或者注释每行不可超过72

Python虽然提供了续行符\，但是在列表中可以忽略续行符，如下所示：

```python
lst = [
    1,
    2,
    3,
    4,
    5
]
print("value : %r\ntype : %r" % (lst, type(lst)))

# value : [1, 2, 3, 4, 5]
# type : <class 'list'>

```

#### 类型转换

列表支持与布尔型、字符串、元组、以及集合类型进行类型转换：

```python
lst = [1, 2, 3]
bLi = bool(lst)
strLi = str(lst)
tupLi = tuple(lst)
setLi = set(lst)

print("value : %r\ntype : %r" % (bLi, type(bLi)))
print("value : %r\ntype : %r" % (strLi, type(strLi)))
print("value : %r\ntype : %r" % (tupLi, type(tupLi)))
print("value : %r\ntype : %r" % (setLi, type(setLi)))

# value : True
# type : <class 'bool'>
# value : '[1, 2, 3]'
# type : <class 'str'>
# value : (1, 2, 3)
# type : <class 'tuple'>
# value : {1, 2, 3}
# type : <class 'set'>

```

如果一个2维列表遵循一定的规律，那么也可以将其转换为字典类型：

```python
lst = [["k1", "v1"], ["k2", "v2"], ["k3", "v3"]]
dictList = dict(lst)

print("value : %r\ntype : %r" % (dictList, type(dictList)))

# value : {'k1': 'v1', 'k2': 'v2', 'k3': 'v3'}
# type : <class 'dict'>

```

#### 四则运算

列表支持与元组，列表进行加法运算：

- +：合并2个列表并生成新列表：

  ```python
  lst1 = [1, 2, 3]
  lst2 = [4, 5, 6]
  newLi = lst1 + lst2
  print(newLi)
  
  # [1, 2, 3, 4, 5, 6]
  
  ```

  

- +=：扩展已有列表，相当于extend()方法：

  ```python
  oldLi = [1, 2, 3]
  newLi = [4, 5, 6]
  oldLi += newLi
  print(oldLi)	# id(oldLi) 不变
  
  # [1, 2, 3, 4, 5, 6]
  
  ```

列表支持与数字进行乘法运算：

- *：生成一个重复旧列表数据项的新列表：

  ```python
  oldLi = [1, 2, 3]
  newLi = oldLi * 3
  print(newLi)
  
  # [1, 2, 3, 1, 2, 3, 1, 2, 3]
  
  ```

  

- *=：扩展已有列表，将已有列表的数据项进行重复添加：

  ```python
  oldLi = [1, 2, 3]
  oldLi *= 3
  print(oldLi)	# id(oldLi) 不变
  
  # [1, 2, 3, 1, 2, 3, 1, 2, 3]
  
  ```



#### 索引切片

列表底层是以一种连续的顺序结构存储数据项，故可以使用索引（index）对数据项进行获取、删除、截取、替换等操作。

```shell
----------------------------|
| A | B | C | D | E | F | G |
----------------------------|
| 0 | 1 | 2 | 3 | 4 | 5 | 6 |
|-7 |-6 |-5 |-4 |-3 |-2 |-1 |

```

正向索引都是从0开始，负向索引都是从-1开始。

**enumerate()**

我们以一个内置函数enumerate()来举例，该函数返回一个迭代器，将其转换为list()后可以查看数据项以及正向索引：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]
print(list(enumerate(lst)))

# [(0, 'A'), (1, 'B'), (2, 'C'), (3, 'D'), (4, 'E'), (5, 'F'), (6, 'G')]

```

更多的关于enumerate()函数的妙用，将会放在循环章节中进行探讨。

**slice()**

slice()函数有三个参数：

- start：索引开始的位置

- stop：索引结束的位置

- step：步长间距，默认为1

  如果为正数代表正取，如果为负数代表倒取

  如果为1代表连续取，如果为2代表隔一个取一个，以此类推

使用方法如下示例，先使用slice()确定截取数据项的范围，然后再使用列表的[]操作形式取出指定范围的数据项。

注意：所有的切片都是顾头不顾尾：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

# 取出A
# 释义：从0开始取，取1个，步长为0
s = slice(0, 1, None)
print(lst[s])

# ['A']

```

**[::]形式**

使用slice()函数会比较繁琐，直接使用[::]形式进行切片会比较简单。

签名如下：

```python
[start:stop:step]
```

参数描述和slice()相同，当某一参数不设置时可省略前面的参数。

增删改截操作演示：

```python
>>> # 获取第2个数据项
>>> lst = ["A", "B", "C", "D", "E", "F", "G"]
>>> lst[1]
'B'
>>> # 删除第3个数据项
>>> del lst[2]
>>> lst
['A', 'B', 'D', 'E', 'F', 'G']
>>> # 从第1个数据项开始向后替换2个数据项，替换内容为123
>>> lst[0:3] = 1,2,3
>>> lst
[1, 2, 3, 'E', 'F', 'G']
>>> # 从第1个数据项开始获取2个数据项
>>> lst[0:3]
[1, 2, 3]
>>> # 试图访问一个超出索引之外的数据项，将引发异常
>>> lst[100]
IndexError: lstst index out of range

```

需要注意的是，如果使用[:]则会创建一个**新的列表**，再将原有列表中的数据项全部引用至新的列表中，类似于浅拷贝的概念。

```python
lst1 = ["A", "B", "C", "D", "E", "F", "G"]
lst2 = lst1[:]

print("value : %r\naddr : %r" % (lst1, id(lst1)))
print("value : %r\naddr : %r" % (lst2, id(lst2)))

# value : ['A', 'B', 'C', 'D', 'E', 'F', 'G']
# addr : 4307969608
# value : ['A', 'B', 'C', 'D', 'E', 'F', 'G']
# addr : 4308270792

```

**正向切片**

正向切片即使用正向索引进行切片，索引从0处开始进行切片。

如下示例：

```python
>>> lst = ["A", "B", "C", "D", "E", "F", "G"]
>>> lst[0:3]
['A', 'B', 'C']

```

**反向切片**

反向切片即使用反向索引进行切片，索引从-1处开始进行切片。

如下示例：

```python
>>> lst = ["A", "B", "C", "D", "E", "F", "G"]
>>> lst[-3:]
['E', 'F', 'G']

```

**多维切片**

列表是支持多维切片的，如下示例，拿出2维列表中的数据项A：

```python
>>> lst = [1, 2, ["A", "B"]]
>>> lst[-1][0]
'A'

```

**高级切片**

反向和正向切片可以混合使用，下面是一些高级切片的用法：

```python
>>> lst = ["A", "B", "C", "D", "E", "F", "G"]
>>> lst[:] ❶
['A', 'B', 'C', 'D', 'E', 'F', 'G']
>>> lst[2:4] ❷
['C', 'D']
>>> lst[::2] ❸
['A', 'C', 'E', 'G'] 
>>> lst[::-2]
['G', 'E', 'C', 'A'] ❹
>>> lst[::-1] ❺
['G', 'F', 'E', 'D', 'C', 'B', 'A'] 
>>> lst[:-5:-2] ❻
['G', 'E']
>>> lst[0::-1] ❼
['A']
>>> lst[5::-2] ❽
['F', 'D', 'B']

```

如何一眼读懂高级切片，通过以下步骤判定：

- 第一步先观察step，是负数还是正数，负数代表倒着取
- 第二步观察start，确定切片的开始位置
- 第三步观察stop，确定切片的结束位置
  上述示例演示的说明，带*的是比较重要的方式。

❶：列表的[:]操作是创建一个新的列表，再将原有列表中的数据项全部引用一次至新的列表*

❷：步长为空，代表正着取，从第2号索引位置的数据项开始，到第4号索引位置的数据项结束，根据顾头不顾尾原则，取2，3号索引的数据项*

❸：步长为2，代表正着取，隔一个取一个，即从0号索引位置的数据项开始，每次往后数到2的时候再取*

❹：步长为-2，代表倒着取，隔一个取一个，即从-1号索引位置的数据项开始，每次向前数到2的时候再取*

❺：步长为-1，代表倒着取，即从-1号索引位置的数据项开始，取到索引0号位置结束*

❻：步长为-2，代表倒着取，隔一个位置取一个，取到-5索引位置结束，根据顾头不顾尾原则，不取-5索引位置的数据项

❼：步长为-1，代表倒着取，开始位置为0，结束位置未标记，则取1个

❽：步长为-2，代表倒着取，隔一个取一个，开始位置为5号索引，则从第5号索引开始向前取

#### 解构方法

使用*语法可对列表进行解构，将列表中的数据项全部提取出来：

```python
lst = [1, 2, 3]
print(*lst)

# 1 2 3

```

我们可以利用*语法的特性，来达到两个列表进行合并产生新列表的效果，类似于+：

```python
lst1 = [1, 2, 3]
lst2 = [4, 5, 6]
result = [*lst1, *lst2]
print(result)

# [1, 2, 3, 4, 5, 6]

```

**解构赋值**

如果一个列表中的数据项需要赋值到变量中，可使用解构赋值，需要注意的是变量接收位置与列表中的数据项位置需要一一对应：

```python
lst = ["A", "B"]
item1, item2 = lst

print(item1, item2)

# A B

```

我们只想取出列表中前2个数据项时，可使用*语法将剩下的数据项全部打包到一个变量中：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]
item1, item2, *otherItems = lst

print(item1, item2)
print(otherItems)

# A B
# ['C', 'D', 'E', 'F', 'G']

```

如果只想取第1个后和最后2个，中间的都不想要怎么办？也可以通过*语法：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]
itemFirst, *_, itemLast1, itemLast2 = lst # ❶

print(itemFirst, itemLast1, itemLast2)
print(_)

# A F G
# ['B', 'C', 'D', 'E']

```

❶：_为匿名变量，参见变量与常量一章节中的释义



#### 常用方法

| 方法名   | 返回值  | 描述                                                         |
| -------- | ------- | ------------------------------------------------------------ |
| append() | None    | 将数据项添加至列表的末尾                                     |
| extend() | None    | 通过附加来自可迭代对象的数据项来扩展列表                     |
| insert() | None    | 在索引之前插入对象                                           |
| pop()    | item    | 删除并返回索引处的项目（默认为-1）。如果列表为空或索引超出范围，则引发IndexError |
| copy()   | list    | 返回L的浅拷贝                                                |
| remove() | None    | 删除列表中第一次出现的数据项。如果不存在该数据项，则引发ValueError |
| clear()  | None    | 从L移除所有元素                                              |
| count()  | integer | 返回数据项在L中出现的次数                                    |
| index()  | integer | 返回第一个数据项在L中出现位置的索引，若值不存在，则抛出ValueError |
| sort()   | None    | 对列表进行原地排序，可指定参数reverse，若不指定该参数则默认升序排列，指定该参数则为降序排列 |

基础公用函数：

| 函数名      | 返回值                                | 描述                                                         |
| ----------- | ------------------------------------- | ------------------------------------------------------------ |
| len()       | integer                               | 返回容器中的项目数                                           |
| enumerate() | iterator for index, value of iterable | 返回一个可迭代对象，其中以小元组的形式包裹数据项与正向索引的对应关系 |
| reversed()  | ...                                   | 详情参见函数章节                                             |
| sorted()    | ...                                   | 详情参见函数章节                                             |

**获取长度**

使用len()方法来获取列表的长度。

返回int类型的值。

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

print(len(lst))

# 7

```

Python在对内置的数据类型使用len()方法时，实际上是会直接的从PyVarObject结构体中获取ob_size属性，这是一种非常高效的策略。

PyVarObject是表示内存中长度可变的内置对象的C语言结构体。

直接读取这个值比调用一个方法要快很多。

**追加元素**

使用append()方法为当前列表追加一个数据项。

返回None：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

lst.append("H")

print(lst)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

```

你也可以使用+=进行操作，但个人并不推荐这样使用。

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

lst += "H"

print(lst)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H']

```

**列表合并**

使用extend()方法来让当前列表与另一个可迭代对象进行合并。

返回None：

```python
lst1 = ["A", "B", "C", "D", "E", "F", "G"]
lst2 = ["H", "J", "K", "L"]

lst1.extend(lst2)

print(lst1)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L']

```

你也可以使用+=进行操作，但个人并不推荐这样使用。

```python
lst1 = ["A", "B", "C", "D", "E", "F", "G"]
lst2 = ["H", "J", "K", "L"]

lst1 += lst2

print(lst1)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'J', 'K', 'L']

```

**插入元素**

使用insert()方法将数据项插入当前列表中的指定位置。

返回None：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

lst.insert(0, "a")

print(lst)

# ['a', 'A', 'B', 'C', 'D', 'E', 'F', 'G']

```

**列表拷贝**

使用copy()方法将当前列表进行浅拷贝。

返回当前列表的拷贝对象：

```python
oldLi = ["A", "B", "C", "D", "E", "F", "G"]
newLi = oldLi.copy()

print(oldLi)
print(newLi)

print(id(oldLi))
print(id(newLi))

print(id(oldLi[0]))
print(id(oldLi[0]))

# ['A', 'B', 'C', 'D', 'E', 'F', 'G']
# ['A', 'B', 'C', 'D', 'E', 'F', 'G']
# 4329305992
# 4329607688
# 4328383520
# 4328383520

```

#### 深浅拷贝

**= 直接赋值**

如果用 = 直接赋值，是非拷贝方法。

这两个列表是等价的，修改其中任何一个列表都会影响到另一个列表。

```python
old = [1,[1,2,3],3]
new = old
old[0] = 0
print(old,new)  # [0, [1, 2, 3], 3] [0, [1, 2, 3], 3]
new[1][1] = 0
print(old,new)  # [0, [1, 0, 3], 3] [0, [1, 0, 3], 3]
```



**浅拷贝**

copy()方法

**对于List来说，其第一层，是实现了深拷贝，但对于其内嵌套的List，仍然是浅拷贝。**

**因为嵌套的List保存的是地址，复制过去的时候是把地址复制过去了，嵌套的List在内存中指向的还是同一个。**

```python
old = [1,[1,2,3],3]
new = old.copy()
 
new[0] = 3
new[1][0] =3
 
'''
---------------------
Before:
[1, [1, 2, 3], 3]
[1, [1, 2, 3], 3]
After:
[1, [3, 2, 3], 3]
[3, [3, 2, 3], 3]
---------------------
'''
```

**列表生成式**

**使用列表生成式产生新列表也是一个浅拷贝方法，只对第一层实现深拷贝。**

```python
old = [1,[1,2,3],3]
new = [i for i in old]
print(new)	# [1, [1, 2, 3], 3]
new[0] = 3
new[1][0] = 3
print(new,old)  # [3, [3, 2, 3], 3] [1, [3, 2, 3], 3]
```

**通过for循环遍历，将元素一个个添加到新列表中。这也是一个浅拷贝方法，只对第一层实现深拷贝。**

```python
old = [1,[1,2,3],3]
new = []
for i in range(len(old)):
    new.append(old[i])
 
new[0] = 3
new[1][0] = 3
 
'''
-----------------------
Before:
[1, [1, 2, 3], 3]
[1, [1, 2, 3], 3]
After:
[1, [3, 2, 3], 3]
[3, [3, 2, 3], 3]
-----------------------
'''
```

**通过使用 [ : ] 切片，可以浅拷贝整个列表，同样的，只对第一层实现深拷贝。**

```python
old = [1,[1,2,3],3]
new = old[:]
 
new[0] = 3
new[1][0] = 3
 
'''
------------------
Before:
[1, [1, 2, 3], 3]
[1, [1, 2, 3], 3]
After:
[1, [3, 2, 3], 3]
[3, [3, 2, 3], 3]
------------------
'''
```

**如果用 deepcopy() 方法，则无论多少层，无论怎样的形式，得到的新列表都是和原来无关的，这是最安全最清爽最有效的方法。**

```python
import copy
old = [1,[1,2,3],3]
new = copy.deepcopy(old)
 
new[0] = 3
new[1][0] = 3
 
'''
-----------------------
Before:
[1, [1, 2, 3], 3]
[1, [1, 2, 3], 3]
After:
[1, [1, 2, 3], 3]
[3, [3, 2, 3], 3]
-----------------------
'''
```

**弹出元素**

使用pop()方法弹出当前列表中在此索引位置的数据项，列表中该数据项将被删除，并返回被弹出的数据项。

若不指定位置，则默认弹出-1号索引位置的数据项：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

popItem1 = lst.pop()
popItem2 = lst.pop(2)

print(lst)
print(popItem1)
print(popItem2)

# ['A', 'B', 'D', 'E', 'F']
# G
# C

```

**删除元素**

使用remove()方法删除当前列表中的数据项，根据数据项的名字进行删除。

如果具有多个同名的数据项，则只会删除第一个。

返回None：

```python
lst = ["A", "A", "B", "C", "D", "E", "F", "G"]

lst.remove("A")

print(lst)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G']

```

我们也可以使用del lst[index]进行数据项的删除：

```python
lst = ["A", "A", "B", "C", "D", "E", "F", "G"]

del lst[0]

print(lst)

# ['A', 'B', 'C', 'D', 'E', 'F', 'G']

```

这种方式还可以删除多个：

```python
lst = ["A", "A", "B", "C", "D", "E", "F", "G"]

del lst[0:3]

print(lst)

# ['C', 'D', 'E', 'F', 'G']

```

**清空元素**

使用clear()方法将当前列表进行清空，即删除所有数据项。

返回None：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

lst.clear()

print(lst)

# []

```

我们也可以使用del lst[:]进行列表的清空：

```python
lst = ["A", "B", "C", "D", "E", "F", "G"]

del lst[:]

print(lst)

# []

```

**统计次数**

使用count()方法统计数据项在该列表中出现的次数。

返回int：

```python
lst = ["A", "B", "C", "D", "E", "F", "G", "A"]

aInLiCount = lst.count("A")

print(aInLiCount)

# 2

```

**查找位置**

使用index()方法找到数据项在当前列表中首次出现的位置索引值，如数据项不存在则抛出异常。

返回int。

```python
lst = ["A", "B", "C", "D", "E", "F", "G", "A"]

aInLiIndex = lst.index("A")

print(aInLiIndex)

# 0

```

**顺序排列**

使用sort()方法将当前列表中的数据项按照ASCII码顺序进行排列，默认从小到大。

可指定参数resverse，用于是否翻转列表，如翻转列表则代表从大到小。

返回None：

```python
lst = ["A", "B", "C", "D", "E", "F", "G", "A"]

lst.sort(reverse=True)

print(lst)

# ['G', 'F', 'E', 'D', 'C', 'B', 'A', 'A']

```

sort()方法内部采用timsort算法，这是一种非常优秀的算法，速度快且稳定。



#### 底层探究

这里引出一个新的概念，线性容器序列：

- 线性是指该对象内部是由连续的内存空间组成

- 容器中能存放不同类型的数据项，如list就是标准的一个容器

- 序列是指具有长度的对象，且该对象能使用index进行内部数据项的操作



容器序列存放的是它们所包含的任意类型的对象的引用，如下定义了一个列表：

```python
x = [“A”, “B”, “C”]
```

它的内部存储结构如下图所示：

![image-20210512210028804](Python\7940e8ecd0ad23f27f63a4477cbf81e2.png)

在CPython源码中，列表数据项的引用为PyObject **ob_item属性，即指针的指针。

**元素调整**
列表中，pop()和insert()方法都具有指定索引值的功能。

如果使用pop(0)，或者insert(0)则都会引起整个列表中数据项的调整。

- pop(0)会将队首的数据项弹出并删除，后面的所有数据项都要向前挪一个位置。1变成0，2变成1，以此类推

- insert(0)会将新的数据项插入至队首，后面的所有数据项都要向后挪一个位置。0变成1，1变成2，以此类推

  

而单纯的使用pop()或者append()则不会发生数据项调整，因为它们总是在队尾做操作。

总而言之，任何一个方法只要不是操作的队尾数据项，都会引起该列表中其他所有数据项的调整。

图示如下：

![image-20210513103433645](Python\a574fca6b2f298cde149bd4141d58283.png)

![image-20210513103539319](Python\c6693f04e7748c3d4ce3c83c2cefdca7.png)

**扩容机制**
在对列表进行添加数据项时，如果列表内部的容量已满则会触发扩容机制。

我们要理解2个概念：

- 容量：容量指的是列表底层在开辟内存时，开辟了多大的内存空间，能够容纳多少数据项，可以理解为一共有多少个槽位

- 大小：大小指的是当前列表中，数据项已占据的容量，可以理解为已用了多少个槽位

  

在CPython源码中，列表容量的属性为Py_ssize_t allocated，而列表大小的属性为Py_ssize_t ob_size

在初始化列表时，容量和大小总是等于数据项的总个数，如：

- 一个空列表，容量和大小都为0
- 有8个槽位的列表，容量和大小都为8

如果对一个已有的列表进行增加数据项的操作时会有以下2条判断，判定当前列表是否需要扩容：

- 当前列表容量 > 已有数据项个数+1 and 已有数据项个数 >= 当前列表容量的一半

  则直接添加数据项，不进行扩容

  并且新增数据项个数 Py_ssize_t ob_size + 1

- 当前列表容量 < 已有数据项个数+1

  则先进行扩容后再添加数据项

  扩容是一种线性增长，增长规律为：0、4、8、16、24、32、40、52、64、76 …，总是为4的倍数

  在扩容时不必担心发生内存溢出，因为内部已经设置了最大值

  为：PY_SSIZE_T_MAX *（9/8）+ 6

  ![image-20210513104211272](Python\525b6f7f260268ffa6f4ee517e8fab1b.png)

**缩容机制**

缩容机制建立在列表有空余空间的情况下。

我们如果使用pop()方法删除了最后一个数据项，其实并不会将最后一个列表槽位所占用的内存空间给释放掉而是进行保留，内部仅进行一次Py_ssize_t ob_size - 1的操作。

这样做的好处是，后面再添加数据项时，其实就不用再次进行扩容了。

但是在添加数据项之前，会判断整个列表的容量是否过大，如果过大即代表还有很多空的位置，此时要进行缩容机制：

- 如果数据项个数 + 1 < 当前列表容量的一半

  则进行缩容，删除空的列表槽位

![image-20210513104548039](Python\7e7e2b588225325ed41d4100ace45f7c.png)

如果是clear()清空列表中的数据项，则直接非常干脆的将容量以及大小都重置为0，并且将该列表所有槽位占据的内存空间进行释放。

**迁徙机制**

因为列表底层是顺序存储，必须占用一个连续的内存空间。

如果在进行扩容时，发现后面连续的内存空间被其他对象所占据，则会将整个列表进行一次拷贝。

然后迁徙到新的位置开辟内存，确保所有的列表槽位都是连续的。

![image-20210513105108068](Python\44f5f03d4c6b97d496ffe92adfe92d6c.png)

**列表缓存**
当删除一个列表之后，会将该列表中槽位引用的数据项地址全部清空。

并且将该列表的引用存放至一个叫做free_list的缓存中，下次如果再需要创建列表，则直接从free_list缓存中获取。

- free_list最多可以缓存80个列表

示例，旧列表被删除后将空列表的引用存放至free_list缓存中，当再次创建一个新列表时，会直接从free_list缓存中获取旧列表，并且填入数据项：

```python
lst1 = [1, 2, 3]
print(id(lst1))
del lst1

lst2 = [4, 5, 6, 7]
print(id(lst2))

# 4405732936
# 4405732936

```

![image-20210513111034466](Python\3a285eb5949eab852909a4077a06a5fa.png)

