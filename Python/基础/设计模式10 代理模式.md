[toc]

# 基本介绍

在代理模式（Proxy Pattern）中，一个类代表另一个类的功能。

- 和[适配器模式](https://so.csdn.net/so/search?q=适配器模式&spm=1001.2101.3001.7020)的区别：适配器模式主要改变所考虑对象的接口，而代理模式不能改变所代理类的接口。
- 和[装饰器](https://so.csdn.net/so/search?q=装饰器&spm=1001.2101.3001.7020)模式的区别：装饰器模式为了增强功能，而代理模式是为了加以控制。

> 特点：为其他对象提供一种代理以控制对这个对象的访问

代理模式属于结构型模式。

# 案例图示

买火车票不一定要去火车站买，也可以在网上买，省去了排队的环节：

![image-20210624122107655](images/110c7b1f3f2e0bdf3db7de85a86f6ddb.png)

# 优缺点

优点：

- 职责清晰
- 高扩展性
- 智能化

缺点：

- 由于在客户端和真实主题之间增加了代理对象，因此有些类型的代理模式可能会造成请求的处理速度变慢
- 实现代理模式需要额外的工作，有些代理模式的实现非常复杂

# 代码实现

用Python实现代理模式：

```python
class TrainStation:
    def buy_tickets(self):
        return "Train ticket"

    def line_up(self):
        print("Users are waiting in line ...")


class Proxy:
    def __init__(self):
        # 与火车站建立联系
        self.train_station = TrainStation()

    def buy_tickets(self):
        self.__request()
        return self.train_station.buy_tickets()

    def __request(self):
        print("I am launching a ticket request to the train station ...")


if __name__ == '__main__':
    get_tickets = Proxy()
    tickets = get_tickets.buy_tickets()
    print(tickets)

# I am launching a ticket request to the train station ...
# Train ticket

```

