[toc]



# 位层次逻辑运算

1 代表真，0 代表假



- 非(NOT), 一元运算符

| X    | NOT X |
| ---- | ----- |
| 0    | 1     |
| 1    | 0     |



- 与(AND)

| X    | Y    | X AND Y |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 0       |
| 1    | 0    | 0       |
| 1    | 1    | 1       |



- 或(OR)

| X    | Y    | X OR Y |
| ---- | ---- | ------ |
| 0    | 0    | 0      |
| 0    | 1    | 1      |
| 1    | 0    | 1      |
| 1    | 1    | 1      |



- 异或(XOR)

有两个输入，如果输入相同，则输出0；如果输入不同，则输出1

| X    | Y    | X XOR Y |
| ---- | ---- | ------- |
| 0    | 0    | 0       |
| 0    | 1    | 1       |
| 1    | 0    | 1       |
| 1    | 1    | 0       |



# 模式层次逻辑运算

多个位 运算同 位层次逻辑运算





# 逻辑运算应用-复位



- AND 指定位通过掩码复位 --- 0

使用掩码复位模式的最左5位。

原码： 10100110  对最左边5位进行复位

​			1	0	1	0	0	1	1	0

AND	0	0	0	0	0	1	1	1		掩码

输出	0	0	0	0	0	1	1	0

说明： 最右边的3位保持不变，而最左边的5位，不管他们先前是什么，都被复位（变为0）



- OR 指定位通过掩码复位 --- 1

  对原码的最左5位进行复位--1

  原码： 		1	0	1	0	1	1	0

  OR				1	1	1	1	1	0	0		掩码

  输出			  1	1	1	1	1	1	0

- XOR 指定的位通过掩码 复位-- 取反

  原码：			1	0	1	0	1	1	0

  XOR				1	1	1	1	1	0	0		掩码

  输出				0	1	0	1	0	1	0



# 移位运算



## 逻辑移位运算

1	0	0	1  往左移1位， 0	0	1	0，最左位1被丢弃，最右位补0

1	0	0	1  往右移1位，0	1	0	0，最左位补0，最右位被丢弃





## 算数移位运算

补码形式，补码--> 十进制需要先转换为正常的二进制，然后计算十进制

算数右移	保留最左边符号位	1010		右移1位	1101	，保留最左的符号位，然后整体右移，最右位被丢弃

例子:

对位模式1001101使用算数右移，模式是二进制补码格式的整数：

解：最左位被保留

算数右移	1	0	0	1	1	0	1	原码

​					1	1	0	0	1	1	0	移位后

原始数是 -103，新的数是 -52，他是-103除以2的结果



算数左移	同逻辑左移

例子：

对位模式11011001使用算数左移，模式是二进制补码格式的整数：

解：最左位被丢弃，最右位补0

算数左移	1	1	0	1	1	0	0	1	原码

​					1	0	1	1	0	0	1	0	移位后

原始数是-39，新的数是 -78，原始数被乘以2，因为没有（下）溢出发生，所以运算合法。



对位模式01111111使用算数左移，模式是二进制补码的整数；

解：最左位被丢弃，0作为最右位被插入

算数左移	0	1	1	1	1	1	1	1	原码

​					1	1	1	1	1	1	1	0 	移位后

原始数是127，新的数是 -2 ，因为（上）溢出发生了，所以结果非法。期望的答案是127*2=254，这个数不能用8位模式表示





# 算数运算



## 加法



A + B

A - B = A + B的补码 (为什么？)

举例：

以二进制补码格式存储两个整数A 和 B，显示 B 如何被加到 A上的

A = 00010001 , B = 00010110

说明: 正整数的补码是其自身（原码）

​		0	0	0	1	0	0	0	1

\+	  0	0	0	1	0	1	1	0

-----------------------------------------------------

​		0	0	1	0	0	1	1	1	

用十进制检查结果: 17 + 22 = 39



A=00011000		B=11101111

A + B = ?

解：注意，最后的进位被舍弃，因为存储器大小只有 8 位。

​		0	0	0	1	1	0	0	0	

\+	  1	1	1	0	1	1	1	1

----------------------------------------------------

1  	0	0	0	0	0	1	1	1		最左位的1 被舍弃

用10进制检查结果 24 + (-17) = 7



## 减法

以二进制补码格式存储两个整数A 和 B，显示 A如何减去B

A = 00011000

B = 11101111

A -B = A + B补码

​		0	0	0	1	1	0	0	0	

\+	  0	0	0	1	0	0	0	1	B的补码

----------------------------

​		0	0	1	0	1	0	0	1

十进制检查结果: 24 - (-17) = 41





# 总结

1. **举个例子，1+1怎么表达呢？**

1的二进制表达为(为了方便用1个字节表示)：00000001

那么1+1即表达为：00000001 + 00000001 = 00000010 = 2

2. **再接着看下面，2-1怎么表达呢？**

2的二进制为：00000010

-1的二进制为：10000001

那么：2-1=2+(-1)=00000010+10000001=10000011=-3

很显然是错误的计算，因为计算机在计算过程中并不是用我们认识的二进制来表达运算的。

我们认识直接转换的二进制呢，是称为：原码。

计算机内部采用补码来计算的。我们先来说什么说原码和补码吧

3. **什么是原码**

维基百科的定义：原码（True form）是电脑运算的名词，是指“未经更改”的码。例如上面举的例子，2的二进制表达为00000010，00000010即是原码。

4. **什么是补码**

维基百科的定义：补码（英语：2's complement）是一种用二进制表示有符号数的方法。

补码是根据原码规则计算而来的：

正数和0的补码：该数字本身。

负数的补码：将其除最高位(即符号位)取反再加1得出的。

那么什么是取反，0变成1，1变成0就是取码了。

举个例子，-1，原码是：10000001

第一步，除最高位取反，得到：11111110

第二步，加1：11111111

最后-1的补码即为：11111111

对了，在转换补码的过程中，还有步骤：取反。取反得出来的数，称为反码。

5. **什么是反码**

反码是一种在计算机中数的机器码表示。对于单个数值（二进制的0和1）而言，对其进行取反操作就是将0变为1，1变为0

反码跟原码是正数时，一样；负数时，反码就是原码符号位除外，其他位按位取反。

反码是在原码和补码转换过程中过渡的一种运算而已。知道了原码和补码的转换，其实也就知道什么是反码了，只是把它抽象出来了。

6. **减法到底是怎么做呢？**

说完了原码，反码和补码，回到最开始的问题，到底怎么运算才对啊？

计算机内部采用补码来计算的。

i. 首先我们要把需要计算的转换成补码

2的原码是：00000010，由于是正数，补码即为本身：00000010。

-1的原码是：10000001，由于是负数，补码为：11111111

ii. 计算机内部是采用补码加法，统一了运算规则。例如把2-1看成是：2+(-1)。于是2-1实际为：

00000010 + 11111111 = 00000001，算出来的其实还是补码，补码需要转换成原码，然后转换成10进制

00000001 是正整数，补码等于原码，所以就是10进制数 1

iii. 最终计算结果是正常的

7. **究极原因：为什么非要补码？**

在我阅读和思考的时候，很多思想是通过时钟循环来表达其本质。

我个人理解为公式的变换，相对容易理解。我们推导一下下面的公式。

10-8=10+(-8)=10+(-1-8)+1=10+[(-1-8)+1]

来到这里，我们停一下。这个公式推导过来是等价的，看看方括号里面是不是和计算机内部计算**取反+1**很相似？

-1是二进制补码是：11111111，-8的原码是：10001000，反码是：11110111，(-1-8)除开高位的运算为：1111111-0001000（这里的8为正整数）=1110111，结合高位即为：11110111，即就是取反的结果，亦即(-1-8)的结果。

方括号里的实质即是[(取反)+1]=[补码],这就是为什么可以使用补码计算了。





# 实数运算

